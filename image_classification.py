# -*- coding: utf-8 -*-
"""image classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18_kG_LdtYgcME82Op-MXvIO7p7sz5PGN
"""

import tensorflow as tf
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.applications.mobilenet_v2 import preprocess_input, decode_predictions
from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt
import requests
from PIL import Image
import io
import os

class ImageClassifier:
    def __init__(self):
        """Initialize the image classifier with pre-trained MobileNetV2"""
        print("Loading pre-trained MobileNetV2 model...")
        # Load pre-trained MobileNetV2 model with ImageNet weights
        self.model = MobileNetV2(weights='imagenet', include_top=True)
        print("Model loaded successfully!")

        # Define our target categories (subset of ImageNet classes)
        self.target_categories = {
            'animals': ['Egyptian_cat', 'golden_retriever', 'tiger', 'elephant', 'panda'],
            'vehicles': ['convertible', 'sports_car', 'pickup', 'motorcycle', 'bicycle'],
            'fruits': ['banana', 'orange', 'apple', 'strawberry', 'pineapple'],
            'household': ['laptop', 'cellular_telephone', 'coffee_mug', 'toaster', 'television'],
            'nature': ['daisy', 'rose', 'sunflower', 'mushroom', 'coral_reef']
        }

    def preprocess_image(self, img_path_or_url):
        """Preprocess image for MobileNetV2 input"""
        try:
            # Handle both local files and URLs
            if img_path_or_url.startswith('http'):
                response = requests.get(img_path_or_url)
                img = Image.open(io.BytesIO(response.content))
            else:
                img = Image.open(img_path_or_url)

            # Convert to RGB if necessary
            if img.mode != 'RGB':
                img = img.convert('RGB')

            # Resize to 224x224 (MobileNetV2 input size)
            img = img.resize((224, 224))

            # Convert to array and add batch dimension
            img_array = image.img_to_array(img)
            img_array = np.expand_dims(img_array, axis=0)

            # Preprocess for MobileNetV2
            img_array = preprocess_input(img_array)

            return img_array, img

        except Exception as e:
            print(f"Error preprocessing image: {e}")
            return None, None

    def classify_image(self, img_path_or_url, top_k=5):
        """Classify a single image"""
        # Preprocess image
        processed_img, original_img = self.preprocess_image(img_path_or_url)

        if processed_img is None:
            return None, None

        # Make prediction
        predictions = self.model.predict(processed_img)

        # Decode predictions to human-readable labels
        decoded_preds = decode_predictions(predictions, top=top_k)[0]

        # Format results
        results = []
        for i, (class_id, label, confidence) in enumerate(decoded_preds):
            results.append({
                'rank': i + 1,
                'label': label.replace('_', ' ').title(),
                'class_id': class_id,
                'confidence': float(confidence),
                'percentage': f"{confidence * 100:.2f}%"
            })

        return results, original_img

    def classify_multiple_images(self, image_list):
        """Classify multiple images and return results"""
        all_results = {}

        for i, img_path in enumerate(image_list):
            print(f"\nClassifying image {i+1}/{len(image_list)}: {img_path}")

            results, original_img = self.classify_image(img_path)

            if results is not None and original_img is not None:
                all_results[f"image_{i+1}"] = {
                    'path': img_path,
                    'predictions': results,
                    'image': original_img
                }

                # Print top prediction
                top_pred = results[0]
                print(f"Top prediction: {top_pred['label']} ({top_pred['percentage']})")
            else:
                print(f"Failed to classify image: {img_path}")
                print("Please check if the file exists or the URL is accessible.")

        return all_results

    def evaluate_on_sample_images(self):
        """Evaluate the classifier on sample images from different categories"""
        # Sample image URLs for testing (you can replace with your own)
        sample_images = [
            "https://images.unsplash.com/photo-1574158622682-e40e69881006?w=400",  # Cat
            "https://images.unsplash.com/photo-1544717297-fa95b6ee9643?w=400",   # Car
            "https://images.unsplash.com/photo-1571771894821-ce9b6c11b08e?w=400", # Banana
            "https://images.unsplash.com/photo-1484704849700-f032a568e944?w=400", # Laptop
            "https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=400", # Flower
        ]

        print("=" * 60)
        print("EVALUATING IMAGE CLASSIFIER")
        print("=" * 60)

        results = self.classify_multiple_images(sample_images)

        return results

    def visualize_results(self, results, figsize=(15, 12)):
        """Visualize classification results"""
        n_images = len(results)

        if n_images == 0:
            print("No results to visualize!")
            return

        # Calculate grid dimensions
        cols = min(3, n_images)
        rows = (n_images + cols - 1) // cols

        fig, axes = plt.subplots(rows, cols, figsize=figsize)

        # Handle single image case
        if n_images == 1:
            axes = [axes]
        elif rows == 1:
            axes = axes.reshape(1, -1)

        for idx, (key, result) in enumerate(results.items()):
            row = idx // cols
            col = idx % cols

            if rows == 1:
                ax = axes[col]
            else:
                ax = axes[row, col]

            # Display image
            if result['image']:
                ax.imshow(result['image'])

            # Create title with top 3 predictions
            title_lines = [f"Image {idx + 1}"]
            for i, pred in enumerate(result['predictions'][:3]):
                title_lines.append(f"{i+1}. {pred['label']}: {pred['percentage']}")

            ax.set_title('\n'.join(title_lines), fontsize=10, pad=10)
            ax.axis('off')

        # Hide unused subplots
        for idx in range(n_images, rows * cols):
            row = idx // cols
            col = idx % cols
            if rows == 1:
                axes[col].axis('off')
            else:
                axes[row, col].axis('off')

        plt.tight_layout()
        plt.show()

    def get_model_info(self):
        """Get information about the model"""
        print("=" * 60)
        print("MODEL INFORMATION")
        print("=" * 60)
        print(f"Model: MobileNetV2")
        print(f"Pre-trained on: ImageNet dataset")
        print(f"Input shape: {self.model.input_shape}")
        print(f"Output classes: {self.model.output_shape[1]} classes")
        print(f"Parameters: {self.model.count_params():,}")
        print("\nTarget Categories:")
        for category, classes in self.target_categories.items():
            print(f"  {category.title()}: {', '.join(classes)}")

def main():
    """Main function to demonstrate the image classifier"""
    # Initialize classifier
    classifier = ImageClassifier()

    # Show model information
    classifier.get_model_info()

    # Evaluate on sample images
    results = classifier.evaluate_on_sample_images()

    # Visualize results
    if results:
        print("\n" + "=" * 60)
        print("DETAILED RESULTS")
        print("=" * 60)

        for key, result in results.items():
            print(f"\n{key.upper()}:")
            print(f"Path: {result['path']}")
            print("Top 5 Predictions:")
            for pred in result['predictions']:
                print(f"  {pred['rank']}. {pred['label']}: {pred['percentage']}")

        # Visualize results
        print("\nGenerating visualization...")
        classifier.visualize_results(results)

    # Example of classifying a single image
    print("\n" + "=" * 60)
    print("SINGLE IMAGE CLASSIFICATION EXAMPLE")
    print("=" * 60)

    # You can replace this URL with any image URL or local file path
    test_image = "https://images.unsplash.com/photo-1583337130417-3346a1be7dee?w=400"

    print(f"Classifying: {test_image}")
    single_result, img = classifier.classify_image(test_image)

    if single_result:
        print("\nPredictions:")
        for pred in single_result:
            print(f"  {pred['rank']}. {pred['label']}: {pred['percentage']}")

if __name__ == "__main__":
    main()

# Additional utility functions for custom dataset evaluation

def evaluate_accuracy_on_custom_dataset(classifier, test_data):
    """
    Evaluate accuracy on a custom dataset
    test_data should be a list of tuples: [(image_path, true_label), ...]
    """
    correct_predictions = 0
    total_predictions = len(test_data)

    results = []

    for img_path, true_label in test_data:
        predictions, _ = classifier.classify_image(img_path, top_k=1)

        if predictions is not None:
            predicted_label = predictions[0]['label'].lower()
            is_correct = true_label.lower() in predicted_label or predicted_label in true_label.lower()

            if is_correct:
                correct_predictions += 1

            results.append({
                'image': img_path,
                'true_label': true_label,
                'predicted_label': predictions[0]['label'],
                'confidence': predictions[0]['confidence'],
                'correct': is_correct
            })
        else:
            print(f"Could not process image: {img_path}")

    accuracy = correct_predictions / total_predictions if total_predictions > 0 else 0

    return accuracy, results

def create_confusion_matrix(results, categories):
    """Create a simple confusion matrix from results"""
    import pandas as pd

    # Extract true and predicted labels
    y_true = [r['true_label'] for r in results]
    y_pred = [r['predicted_label'] for r in results]

    # Create confusion matrix
    from sklearn.metrics import confusion_matrix, classification_report

    cm = confusion_matrix(y_true, y_pred, labels=categories)
    report = classification_report(y_true, y_pred, labels=categories)

    return cm, report

# Example usage with working URLs and proper error handling:

# WORKING EXAMPLE - Run this code:
if __name__ == "__main__":
    # Initialize classifier
    classifier = ImageClassifier()

    print(" Testing with working image URLs...")

    # Test with accessible image URLs
    working_urls = [
        "https://upload.wikimedia.org/wikipedia/commons/4/4d/Cat_November_2010-1a.jpg",  # Cat
        "https://upload.wikimedia.org/wikipedia/commons/5/50/Vd-orig.jpg",  # Car
        "https://upload.wikimedia.org/wikipedia/commons/8/8a/Banana-Single.jpg",  # Banana
    ]

    print("\n" + "="*50)
    print("CLASSIFYING WORKING IMAGES")
    print("="*50)

    for i, url in enumerate(working_urls, 1):
        print(f"\n📸 Testing image {i}: {url.split('/')[-1]}")
        results, img = classifier.classify_image(url)

        if results is not None:
            print("✅ Classification successful!")
            print("Top 3 predictions:")
            for pred in results[:3]:
                print(f"  {pred['rank']}. {pred['label']}: {pred['percentage']}")
        else:
            print("❌ Classification failed")

    print("\n" + "="*50)
    print("HOW TO USE WITH YOUR OWN IMAGES")
    print("="*50)
    print("""
 For LOCAL images, make sure files exist:
   classifier.classify_image("actual_image.jpg")

 For URL images, use direct image links:
   classifier.classify_image("https://example.com/image.jpg")

 Create a folder with your images:
   import os
   image_folder = "my_images/"
   if os.path.exists(image_folder):
       image_files = [os.path.join(image_folder, f) for f in os.listdir(image_folder)
                     if f.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp'))]
       results = classifier.classify_multiple_images(image_files)
    """)

# Function to download and test with sample images
def download_sample_images():
    """Download sample images for testing"""
    import urllib.request
    import os

    # Create sample_images directory
    os.makedirs("sample_images", exist_ok=True)

    sample_urls = {
        "cat.jpg": "https://upload.wikimedia.org/wikipedia/commons/4/4d/Cat_November_2010-1a.jpg",
        "car.jpg": "https://upload.wikimedia.org/wikipedia/commons/5/50/Vd-orig.jpg",
        "banana.jpg": "https://upload.wikimedia.org/wikipedia/commons/8/8a/Banana-Single.jpg",
        "laptop.jpg": "https://upload.wikimedia.org/wikipedia/commons/0/0b/ThinkPad_R51.jpg",
        "flower.jpg": "https://upload.wikimedia.org/wikipedia/commons/5/5b/Rosa_villosa.jpg"
    }

    print(" Downloading sample images...")
    downloaded_files = []

    for filename, url in sample_urls.items():
        try:
            filepath = os.path.join("sample_images", filename)
            urllib.request.urlretrieve(url, filepath)
            downloaded_files.append(filepath)
            print(f" Downloaded: {filename}")
        except Exception as e:
            print(f" Failed to download {filename}: {e}")

    return downloaded_files

